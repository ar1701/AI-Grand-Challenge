/**
 * Comprehensive Vulnerability Analysis Test
 * Uses orchestration with multiple specialized agents for in-depth security analysis
 */

const axios = require('axios');
const fs = require('fs');
const path = require('path');

const API_URL = 'http://localhost:8080/orchestrate';

// ANSI color codes for better output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function section(title) {
  console.log('\n' + '='.repeat(80));
  log(title, 'bright');
  console.log('='.repeat(80) + '\n');
}

/**
 * Main vulnerability analysis test
 */
async function testVulnerabilityAnalysis() {
  try {
    section('ğŸ”’ COMPREHENSIVE VULNERABILITY ANALYSIS TEST');

    // Project to analyze
    const projectPath = '/Users/ayushraj/Desktop/GitHub Desktop/AI-Grand-Challenge/backend';
    
    log(`ğŸ“ Target Project: ${projectPath}`, 'cyan');
    log(`ğŸ¤– Analysis Engine: ${process.env.ANALYSIS_ENGINE || 'gemini'}`, 'cyan');
    
    // Comprehensive vulnerability analysis goal
    const goal = `
Perform a comprehensive analysis of this Node.js backend project covering security vulnerabilities, cross-file bugs, and business-logic edge cases:

**CRITICAL REQUIREMENTS:**
- Every finding MUST include: actual file path, line numbers, vulnerable code snippet (or failing/edge-case path), and specific fix
- NO generic messages like "files not found" or "cannot access"
- Use dependency_graph() first to find actual files, then analyze them
- Provide REAL vulnerabilities/bugs/edge cases from REAL code you actually read

STRATEGY:
1. First, use dependency_graph() to understand the project structure and identify all actual files
2. Spawn specialized agents to perform parallel, deep analysis of REAL files:
   
  ğŸ” Agent 1 - Authentication & Authorization Analysis:
  - Find and READ actual authentication files (app.js, any auth middleware)
  - Analyze authentication mechanisms (JWT, sessions, API keys)
  - Report SPECIFIC vulnerabilities and edge cases with file names, line numbers, and code
  - Check for authorization bypass vulnerabilities and missing guards on sensitive endpoints
  - Identify insecure password storage/handling
   
  ğŸ” Agent 2 - Input Validation, Injection & Edge Cases:
  - Find and READ actual request handling files
  - Analyze user input handling and error paths
  - Report injection vulnerabilities with exact code
  - Check SQL/NoSQL/command injection, XSS, CSRF, upload security
  - Identify edge cases (null/undefined inputs, empty payloads, oversized payloads) and note impacted call sites via dependency_graph()
   
  ğŸ” Agent 3 - API Security, Cross-File Bugs & Rate Limiting:
  - Find and READ API endpoint files (app.js, route files)
  - Analyze endpoints for missing security controls and rate limits
  - Report cross-file bugs where handlers/controllers/validators disagree (e.g., type/shape mismatches) and note affected callers
  - Identify exposed sensitive endpoints, information disclosure, and CORS issues
   
  ğŸ” Agent 4 - Dependency, Configuration & Propagating Edge Cases:
  - READ actual package.json for vulnerable dependencies
  - Check environment variable handling
  - Look for hardcoded secrets/credentials
  - Analyze Docker/deployment configs
  - Identify config-driven edge cases (e.g., missing env vars leading to crashes/default-insecure states) and downstream impact across files
   
  ğŸ” Agent 5 - Code Execution, Cross-Module Logic & Business Edge Cases:
  - Find and READ utility files, agent files, tool files
  - Check for unsafe code execution (eval, Function constructor, etc.)
  - Analyze file system operations for path traversal
  - Look for insecure deserialization and race conditions
  - Identify business logic edge cases (state transitions, quotas, idempotency, ordering) and map which downstream callers are affected

3. Each agent MUST:
  - Use dependency_graph() to map impact: list affected files/functions for each finding (cross-file / business logic / edge case)
  - Use file_read() to examine relevant files thoroughly
  - Provide specific line numbers and ACTUAL code snippets for each finding or edge-case path
  - Rate severity (CRITICAL, HIGH, MEDIUM, LOW)
  - Suggest concrete remediation steps with fixed code and note any dependent files needing coordinated changes

4. Provide AT LEAST 3-5 concrete findings per agent from ACTUAL code, including edge cases and cross-file logic bugs.

**MANDATORY OUTPUT FORMAT FOR EACH FINDING:**

#### [ğŸ”´ CRITICAL / ğŸŸ  HIGH / ğŸŸ¡ MEDIUM / ğŸ”µ LOW] - [Specific Vulnerability Name]

**File:** \`path/to/actual/file.js\`
**Line:** \`45-48\`

**Vulnerable Code:**
\`\`\`javascript
// Copy ACTUAL code from the file
const query = "SELECT * FROM users WHERE id = " + userId;
\`\`\`

**Issue:** Explain the specific security problem with THIS code

**Fix:**
\`\`\`javascript
// Show the EXACT secure replacement
const query = "SELECT * FROM users WHERE id = ?";
db.execute(query, [userId]);
\`\`\`

**Impact:** What an attacker could do with THIS specific vulnerability

---

NO EXCUSES. NO "FILES NOT FOUND". FIND REAL FILES AND REPORT REAL VULNERABILITIES.
`;

    log('\nğŸ“‹ Starting comprehensive vulnerability analysis...', 'yellow');
    log('â³ This will spawn 5 specialized security analysis agents...\n', 'yellow');

    const startTime = Date.now();

    // Make API request
    const response = await axios.post(API_URL, {
      goal: goal,
      projectPath: projectPath
    }, {
      timeout: 600000 // 10 minute timeout for thorough analysis
    });

    const endTime = Date.now();
    const executionTime = ((endTime - startTime) / 1000).toFixed(2);

    const { success, result, spawnedAgents, agentResults, conversationTurns, error } = response.data;

    if (!success) {
      log(`\nâŒ Analysis failed: ${error}`, 'red');
      return;
    }

    log(`âœ… Analysis completed in ${executionTime}s`, 'green');
    log(`ğŸ”„ Conversation turns: ${conversationTurns}`, 'cyan');
    log(`ğŸ¤– Spawned agents: ${spawnedAgents?.length || 0}`, 'cyan');

    // Display spawned agents
    if (spawnedAgents && spawnedAgents.length > 0) {
      section('ğŸ¤– SPECIALIZED SECURITY AGENTS DEPLOYED');
      spawnedAgents.forEach((agent, index) => {
        log(`${index + 1}. ${agent.agentId}: ${agent.purpose}`, 'cyan');
      });
    }

    // Display detailed agent results
    if (agentResults && agentResults.length > 0) {
      section('ğŸ” DETAILED SECURITY FINDINGS BY AGENT');
      
      agentResults.forEach((agentResult, index) => {
        console.log('\n' + '-'.repeat(80));
        log(`\nğŸ”¹ ${agentResult.agentId.toUpperCase()}`, 'magenta');
        log(`Purpose: ${agentResult.purpose}`, 'cyan');
        log(`Status: ${agentResult.success ? 'âœ… Success' : 'âŒ Failed'}`, agentResult.success ? 'green' : 'red');
        
        if (agentResult.success) {
          log(`Execution time: ${agentResult.executionTime}ms`, 'cyan');
          log(`Tool calls: ${agentResult.toolCallCount}`, 'cyan');
          
          if (agentResult.result && agentResult.result.message) {
            console.log('\nğŸ“„ Findings:\n');
            
            // Display the full analysis
            const message = agentResult.result.message;
            
            // Highlight severity levels
            const highlighted = message
              .replace(/CRITICAL/g, `${colors.red}${colors.bright}CRITICAL${colors.reset}`)
              .replace(/HIGH/g, `${colors.red}HIGH${colors.reset}`)
              .replace(/MEDIUM/g, `${colors.yellow}MEDIUM${colors.reset}`)
              .replace(/LOW/g, `${colors.blue}LOW${colors.reset}`)
              .replace(/âœ“/g, `${colors.green}âœ“${colors.reset}`)
              .replace(/âœ—/g, `${colors.red}âœ—${colors.reset}`);
            
            console.log(highlighted);
          }
        } else {
          log(`Error: ${agentResult.error}`, 'red');
        }
        
        console.log('\n' + '-'.repeat(80));
      });
    }

    // Display orchestrator's final summary
    section('ğŸ“Š ORCHESTRATOR FINAL SUMMARY');
    
    if (result && result.message) {
      console.log(result.message);
    }

    // Generate vulnerability statistics
    if (agentResults && agentResults.length > 0) {
      section('ğŸ“ˆ VULNERABILITY STATISTICS');
      
      const stats = {
        totalAgents: agentResults.length,
        successfulAgents: agentResults.filter(r => r.success).length,
        failedAgents: agentResults.filter(r => !r.success).length,
        totalExecutionTime: agentResults.reduce((sum, r) => sum + (r.executionTime || 0), 0),
        totalToolCalls: agentResults.reduce((sum, r) => sum + (r.toolCallCount || 0), 0)
      };

      log(`Total Agents Deployed: ${stats.totalAgents}`, 'cyan');
      log(`Successful Analyses: ${stats.successfulAgents}`, 'green');
      log(`Failed Analyses: ${stats.failedAgents}`, stats.failedAgents > 0 ? 'red' : 'cyan');
      log(`Combined Agent Execution Time: ${stats.totalExecutionTime}ms`, 'cyan');
      log(`Total Tool Calls: ${stats.totalToolCalls}`, 'cyan');
      log(`Average Time per Agent: ${(stats.totalExecutionTime / stats.totalAgents).toFixed(2)}ms`, 'cyan');

      // Count severity mentions across all results
      let severityCounts = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
      agentResults.forEach(ar => {
        if (ar.result?.message) {
          const msg = ar.result.message;
          severityCounts.CRITICAL += (msg.match(/CRITICAL/g) || []).length;
          severityCounts.HIGH += (msg.match(/HIGH/g) || []).length;
          severityCounts.MEDIUM += (msg.match(/MEDIUM/g) || []).length;
          severityCounts.LOW += (msg.match(/LOW/g) || []).length;
        }
      });

      console.log('\nSeverity Mentions:');
      log(`  ğŸ”´ CRITICAL: ${severityCounts.CRITICAL}`, 'red');
      log(`  ğŸŸ  HIGH: ${severityCounts.HIGH}`, 'red');
      log(`  ğŸŸ¡ MEDIUM: ${severityCounts.MEDIUM}`, 'yellow');
      log(`  ğŸ”µ LOW: ${severityCounts.LOW}`, 'blue');
    }

    section('âœ… VULNERABILITY ANALYSIS COMPLETE');
    log('ğŸ¯ Review the findings above and prioritize remediation based on severity.', 'green');

  } catch (error) {
    log('\nâŒ Test failed with error:', 'red');
    console.error(error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
    }
    process.exit(1);
  }
}

// Run the test
log('\nğŸš€ Starting Comprehensive Vulnerability Analysis...', 'bright');
log('ğŸ“ Make sure the backend server is running on http://localhost:8080\n', 'yellow');

testVulnerabilityAnalysis();
